<!DOCTYPE html>
<html class="nojs" lang="zh-cn" dir="ltr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>kubernetes之StatefulSet – psycode - better code, better life.</title>
<meta name="description" content="概述 RC、Deployment、DaemonSet都是面向无状态的服务，它们所管理的Pod的IP、名字，启停顺序等都是随机的，而StatefulSet是什么？顾名思义，有状态的集合，管理所有有状态的服务，比如MySQL、MongoDB集群等。 StatefulSet本质上是Deployment的一种变体，在v1.9版本中已成为GA版本， …">
<meta name="created" content="2020-08-22T12:47:25+0800">
<meta name="modified" content="2020-08-22T12:47:25+0800">
<meta name="author" content="sypeng">
<meta name="contact" content="psyucc@163.com">
<meta property="og:site_name" content="psycode - better code, better life.">
<meta property="og:title" content="kubernetes之StatefulSet">
<meta property="og:url" content="https://sh1yu.github.io/post/kubernetes-statefulset/">
<meta property="og:type" content="article">

<meta name="generator" content="Hugo 0.87.0" />
<meta name="msapplication-TileColor" content="#ffffff">
<meta name="theme-color" content="#ffffff">


<link rel="canonical" href="https://sh1yu.github.io/post/kubernetes-statefulset/">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">

<link rel="stylesheet" href="/css/mobile.2ab74aa64785dcab8114959e76ca140cf76207cd85989bc6d4fc3b12f734a09e.css" media="screen">
<link rel="stylesheet" href="/css/styles.220f12cbeefa3ca61dd63c4390295bf3974c4ba9557837d5e408db1b40a477ee.css">
<link rel="stylesheet" href="/css/print.27fc184f8670f41a2690985390779e7b20335a8fadff8fa015cf9417ffe50c36.css" media="print">

<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "headline": "kubernetes之StatefulSet",
    "datePublished": "2020-08-22T12:47:25+08:00",
    "dateModified": "2020-08-22T12:47:25+08:00",
    "url" : "https://sh1yu.github.io/post/kubernetes-statefulset/",
    "description": "概述 RC、Deployment、DaemonSet都是面向无状态的服务，它们所管理的Pod的IP、名字，启停顺序等都是随机的，而StatefulSet是什么？顾名思义，有状态的集合，管理所有有状态的服务，比如MySQL、MongoDB集群等。 StatefulSet本质上是Deployment的一种变体，在v1.9版本中已成为GA版本， …",
    "keywords": ["k8s"],
    "author": {
      "@type": "Person",
      "name": "sypeng"
    },
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https://sh1yu.github.io"
    },
    "publisher": {
      "@type": "Organization",
      "name": "psycode - better code, better life.",
      "url": "https://sh1yu.github.io"
    }
  }
</script>

<script src="/js/script-early.min.3b0e641814c87f6a1d6ffa5e7d597f29faa8ce11482541e8801dc34013817c91.js"></script>
<script defer src="/js/lib/jquery.slim.min.bbb7b9921ca2b61948753a6edb63c78443663dc45d1621d18e102e1dcb34e512.js"></script>
<script defer src="/js/lib/umbrella.min.6e17830ccdded0a13b96d6993865b58202bc2ee750e5892a51858ab048b2bebb.js"></script>
<script defer src="/js/mobile.min.abb9438113cb72181ecda30b9375cc0771c7ce2e7354414a7c1296b45cf47135.js"></script>
<script src="/js/lib/js.cookie.min.31d1799663bbb6029214d90ba7db9cdc725fa02c16d4b090add3721e44238b6b.js"></script>
<script defer src="/js/cookieconsent.min.21a8d7c181aecb9bb5b91b2e1735d9fd9d283a8a752e9dcdf33c052137987f2b.js"></script>
<script defer src="/js/script.min.c2752732454d16255cfd30375b9a3e48a37b7b809c917b33920889c859ba1300.js"></script>


</head>

<body class="single-page">
<div class="page layout__page layout__sidebar-second">
<header class="header layout__header">

<h1 class="header__site-name">
<a href="/" title="Home" class="header__site-link" rel="home"><span>psycode - better code, better life.</span></a>
</h1>
<div class="region header__region">
</div>
</header>

<nav class="main-menu layout__navigation">
<h2 class="visually-hidden">Main menu</h2>
<ul class="navbar">
<li><a href="/">Home</a></li>
<li><a href="/post/" class="active" aria-current="page">Posts</a></li>
</ul>
</nav>


<main class="main layout__main">
<article class="section-post single-view">
<header>
<h1 class="title title-submitted">kubernetes之StatefulSet</h1>
<div class="submitted">
<span class="author" itemprop="author">sypeng</span> - <time class="created-date" datetime="2020-08-22T12:47:25&#43;08:00">22 August, 2020</time>
</div>
<div class="tags">
Tags:
<ul>
<li><a href="/tags/k8s">k8s</a></li>
</ul>
</div>
</header>
<div class="content">
<h2 id="概述">概述</h2>
<p>RC、Deployment、DaemonSet都是面向无状态的服务，它们所管理的Pod的IP、名字，启停顺序等都是随机的，而StatefulSet是什么？顾名思义，有状态的集合，管理所有有状态的服务，比如MySQL、MongoDB集群等。</p>
<p>StatefulSet本质上是Deployment的一种变体，在v1.9版本中已成为<strong>GA</strong>版本，它为了解决有状态服务的问题，它所管理的Pod拥有固定的Pod名称，启停顺序，在StatefulSet中，Pod名字称为网络标识(hostname)，还必须要用到共享存储。</p>
<p>在Deployment中，与之对应的服务是service，而在StatefulSet中与之对应的headless service，headless service，即无头服务，与service的区别就是它没有Cluster IP，解析它的名称时将返回该Headless Service对应的全部Pod的Endpoint列表。</p>
<p>除此之外，StatefulSet在Headless Service的基础上又为StatefulSet控制的每个Pod副本创建了一个DNS域名，这个域名的格式为：</p>
<pre><code>$(podname).(headless server name)   
FQDN： $(podname).(headless server name).namespace.svc.cluster.local
</code></pre><h2 id="statefulset示例">StatefulSet示例</h2>
<p>接下来看一些示例，演示下上面所说的特性，以加深理解。</p>
<pre><code>apiVersion: v1
kind: Service
metadata:
  name: nginx
  labels:
    app: nginx
spec:
  ports:
  - port: 80
    name: web
  clusterIP: None
  selector:
    app: nginx
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: web
spec:
  selector:
    matchLabels:
      app: nginx # has to match .spec.template.metadata.labels
  serviceName: &quot;nginx&quot;  #声明它属于哪个Headless Service.
  replicas: 3 # by default is 1
  template:
    metadata:
      labels:
        app: nginx # has to match .spec.selector.matchLabels
    spec:
      terminationGracePeriodSeconds: 10
      containers:
      - name: nginx
        image: k8s.gcr.io/nginx-slim:0.8
        ports:
        - containerPort: 80
          name: web
        volumeMounts:
        - name: www
          mountPath: /usr/share/nginx/html
  volumeClaimTemplates:   #可看作pvc的模板
  - metadata:
      name: www
    spec:
      accessModes: [ &quot;ReadWriteOnce&quot; ]
      storageClassName: &quot;gluster-heketi&quot;  #存储类名，改为集群中已存在的
      resources:
        requests:
          storage: 1Gi
</code></pre><p>通过该配置文件，可看出StatefulSet的三个组成部分：</p>
<ul>
<li>Headless Service：名为nginx，用来定义Pod网络标识( DNS domain)。</li>
<li>StatefulSet：定义具体应用，名为Nginx，有三个Pod副本，并为每个Pod定义了一个域名。</li>
<li>volumeClaimTemplates： 存储卷申请模板，创建PVC，指定pvc名称大小，将自动创建pvc，且pvc必须由存储类供应。</li>
</ul>
<blockquote>
<p><strong>为什么需要 headless service 无头服务？</strong>
在用Deployment时，每一个Pod名称是没有顺序的，是随机字符串，因此是Pod名称是无序的，但是在statefulset中要求必须是有序 ，每一个pod不能被随意取代，pod重建后pod名称还是一样的。而pod IP是变化的，所以是以Pod名称来识别。pod名称是pod唯一性的标识符，必须持久稳定有效。这时候要用到无头服务，它可以给每个Pod一个唯一的名称 。</p>
</blockquote>
<blockquote>
<p><strong>为什么需要volumeClaimTemplate？</strong>
对于有状态的副本集都会用到持久存储，对于分布式系统来讲，它的最大特点是数据是不一样的，所以各个节点不能使用同一存储卷，每个节点有自已的专用存储，但是如果在Deployment中的Pod template里定义的存储卷，是所有副本集共用一个存储卷，数据是相同的，因为是基于模板来的 ，而statefulset中每个Pod都要自已的专有存储卷，所以statefulset的存储卷就不能再用Pod模板来创建了，于是statefulSet使用volumeClaimTemplate，称为卷申请模板，它会为每个Pod生成不同的pvc，并绑定pv， 从而实现各pod有专用存储。这就是为什么要用volumeClaimTemplate的原因。</p>
</blockquote>
<p>创建：</p>
<pre><code>$ kubectl create -f nginx.yaml 
service &quot;nginx&quot; created
statefulset &quot;web&quot; created
</code></pre><p>看下这三个Pod创建过程：</p>
<pre><code>#第一个是创建web-0
$ kubectl get pod
web-0                     1/1       ContainerCreating   0          51s

#待web-0 running且ready时，创建web-1
$ kubectl get pod
web-0                     1/1       Running             0          51s
web-1                     0/1       ContainerCreating   0          42s

#待web-1 running且ready时，创建web-2
$ kubectl get pod
web-0                     1/1       Running             0          1m
web-1                     1/1       Running             0          45s
web-2                     1/1       ContainerCreating   0          36s

#最后三个Pod全部running且ready
$ kubectl get pod
NAME                      READY     STATUS    RESTARTS   AGE
web-0                     1/1       Running   0          4m
web-1                     1/1       Running   0          3m
web-2                     1/1       Running   0          1m
</code></pre><p>根据volumeClaimTemplates自动创建的PVC</p>
<pre><code>$ kubectl get pvc
NAME              STATUS    VOLUME                                  CAPACITY   ACCESS MODES   STORAGECLASS     AGE
www-web-0         Bound     pvc-ecf003f3-828d-11e8-8815-000c29774d39   2G        RWO          gluster-heketi   7m
www-web-1         Bound     pvc-0615e33e-828e-11e8-8815-000c29774d39   2G        RWO          gluster-heketi   6m
www-web-2         Bound     pvc-43a97acf-828e-11e8-8815-000c29774d39   2G        RWO          gluster-heketi   4m
</code></pre><blockquote>
<p>如果集群中没有StorageClass的动态供应PVC的机制，也可以提前手动创建多个PV、PVC，手动创建的PVC名称必须符合之后创建的StatefulSet命名规则：<strong>(volumeClaimTemplates.name)-(pod_name)</strong></p>
</blockquote>
<p>Statefulset名称为web 三个Pod副本: web-0，web-1,web-2，volumeClaimTemplates名称为：www，那么自动创建出来的PVC名称为www-web[0-2]，为每个Pod创建一个PVC。
<strong>规律总结：</strong></p>
<ul>
<li>匹配Pod name(网络标识)的模式为：<strong>$(statefulset名称)-$(序号)</strong>，比如上面的示例：web-0，web-1，web-2。</li>
<li>StatefulSet为每个Pod副本创建了一个DNS域名，这个域名的格式为： <strong>$(podname).(headless server name)</strong>，也就意味着服务间是通过Pod域名来通信而非Pod IP，因为当Pod所在Node发生故障时，Pod会被飘移到其它Node上，Pod IP会发生变化，但是Pod域名不会有变化。</li>
<li>StatefulSet使用Headless服务来控制Pod的域名，这个域名的FQDN为：<strong>$(service name).$(namespace).svc.cluster.local</strong>，其中，“cluster.local”指的是集群的域名。</li>
<li>根据volumeClaimTemplates，为每个Pod创建一个pvc，pvc的命名规则匹配模式：<strong>(volumeClaimTemplates.name)-(pod_name)</strong>，比如上面的volumeMounts.name=www， Pod name=web-[0-2]，因此创建出来的PVC是www-web-0、www-web-1、www-web-2。</li>
<li>删除Pod不会删除其pvc，手动删除pvc将自动释放pv。
关于Cluster Domain、headless service名称、StatefulSet 名称如何影响StatefulSet的Pod的DNS域名的示例：</li>
</ul>
<table>
<thead>
<tr>
<th>Cluster Domain</th>
<th>Service (ns/name)</th>
<th>StatefulSet (ns/name)</th>
<th>StatefulSet Domain</th>
<th>Pod DNS</th>
<th>Pod Hostname</th>
</tr>
</thead>
<tbody>
<tr>
<td>cluster.local</td>
<td>default/nginx</td>
<td>default/web</td>
<td>nginx.default.svc.cluster.local</td>
<td>web-{0..N-1}.nginx.default.svc.cluster.local</td>
<td>web-{0..N-1}</td>
</tr>
<tr>
<td>cluster.local</td>
<td>foo/nginx</td>
<td>foo/web</td>
<td>nginx.foo.svc.cluster.local</td>
<td>web-{0..N-1}.nginx.foo.svc.cluster.local</td>
<td>web-{0..N-1}</td>
</tr>
<tr>
<td>kube.local</td>
<td>foo/nginx</td>
<td>foo/web</td>
<td>nginx.foo.svc.kube.local</td>
<td>web-{0..N-1}.nginx.foo.svc.kube.local</td>
<td>web-{0..N-1}</td>
</tr>
</tbody>
</table>
<p><strong>Statefulset的启停顺序：</strong></p>
<ul>
<li>有序部署：部署StatefulSet时，如果有多个Pod副本，它们会被顺序地创建（从0到N-1）并且，在下一个Pod运行之前所有之前的Pod必须都是Running和Ready状态。</li>
<li>有序删除：当Pod被删除时，它们被终止的顺序是从N-1到0。</li>
<li>有序扩展：当对Pod执行扩展操作时，与部署一样，它前面的Pod必须都处于Running和Ready状态。　</li>
</ul>
<p><strong>Statefulset Pod管理策略：</strong>
在v1.7以后，通过允许修改Pod排序策略，同时通过.spec.podManagementPolicy字段确保其身份的唯一性。</p>
<ul>
<li>OrderedReady：上述的启停顺序，默认设置。</li>
<li>Parallel：告诉StatefulSet控制器并行启动或终止所有Pod，并且在启动或终止另一个Pod之前不等待前一个Pod变为Running and Ready或完全终止。</li>
</ul>
<p><strong>StatefulSet使用场景：</strong></p>
<ul>
<li>稳定的持久化存储，即Pod重新调度后还是能访问到相同的持久化数据，基于PVC来实现。</li>
<li>稳定的网络标识符，即Pod重新调度后其PodName和HostName不变。</li>
<li>有序部署，有序扩展，基于init containers来实现。</li>
<li>有序收缩。</li>
</ul>
<h2 id="更新策略">更新策略</h2>
<p>在Kubernetes 1.7及更高版本中，通过.spec.updateStrategy字段允许配置或禁用Pod、labels、source request/limits、annotations自动滚动更新功能。</p>
<p><strong>OnDelete</strong>：通过.spec.updateStrategy.type 字段设置为OnDelete，StatefulSet控制器不会自动更新StatefulSet中的Pod。用户必须手动删除Pod，以使控制器创建新的Pod。</p>
<p><strong>RollingUpdate</strong>：通过.spec.updateStrategy.type 字段设置为RollingUpdate，实现了Pod的自动滚动更新，如果.spec.updateStrategy未指定，则此为默认策略。</p>
<p>StatefulSet控制器将删除并重新创建StatefulSet中的每个Pod。它将以Pod终止（从最大序数到最小序数）的顺序进行，一次更新每个Pod。在更新下一个Pod之前，必须等待这个Pod Running and Ready。</p>
<p><strong>Partitions</strong>: 通过指定 .spec.updateStrategy.rollingUpdate.partition 来对 RollingUpdate 更新策略进行分区，如果指定了分区，则当 StatefulSet 的 .spec.template 更新时，具有大于或等于分区序数的所有 Pod 将被更新。</p>
<p>具有小于分区的序数的所有 Pod 将不会被更新，即使删除它们也将被重新创建。如果 StatefulSet 的 .spec.updateStrategy.rollingUpdate.partition 大于其 .spec.replicas，则其 .spec.template 的更新将不会传播到 Pod。在大多数情况下，不需要使用分区。</p>


<aside class="related layout__related">
</aside>
</div>
</article>
</main>


<aside class="sidebar layout__second-sidebar">
<section>
<h4 class="menu"><a href="/post/" class="active" aria-current="page">Posts</a></h4>
<ul class="menu">
<li><a href="/post/golang%E7%BB%84%E5%90%88%E6%8E%A5%E5%8F%A3%E4%BB%A5%E5%8F%8A%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/">golang组合、接口以及反序列化</a></li>
<li><a href="/post/%E4%B8%80%E6%AC%A1springboot&#43;dubbo%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/">一次springboot&#43;dubbo的项目实战</a></li>
<li><a href="/post/vscode%E9%85%8D%E7%BD%AEcpp%E5%A4%96%E9%83%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E4%BE%9D%E8%B5%96/">Vscode配置cpp外部头文件依赖</a></li>
<li><a href="/post/install-mysql-in-k8s/">在k8s集群中部署mysql</a></li>
<li><a href="/post/sign-model/">SIGN模型找到天赋</a></li>
<li><a href="/post/knowledge-to-ability/">将知识内化成能力</a></li>
<li><a href="/post/iceberg-model/">冰山模型</a></li>
<li><a href="/post/kubernetes-statefulset/" class="active" aria-current="page">kubernetes之StatefulSet</a></li>
<li><a href="/post/vert.x-and-future/">Vert.x线程与Future</a></li>
<li><a href="/post/archlinux-operation/">archlinux使用操作拾遗</a></li>
<li><a href="/post/run-gogs-with-docker/">使用docker运行gogs服务</a></li>
</ul>
</section>
</aside>
<footer class="footer layout__footer">
<p>This site is licensed under a (<a href="https://creativecommons.org/licenses/by-sa/4.0/)">https://creativecommons.org/licenses/by-sa/4.0/)</a>. [Creative Commons Attribution-ShareAlike 4.0 International License]</p>
<p>A <a href="https://example.org/">example.org</a> production.</p>
<p>Powered by <a href="https://gohugo.io/">Hugo</a> and the <a href="https://github.com/frjo/hugo-theme-zen">Zen theme</a>.</p>
</footer>
<div class="cookieconsent layout__cookieconsent hidden">
  <div class="cookieconsent__message">
    This website uses non essential cookies for tracking and analytics that you can accept or decline.
    
  </div>
  <div class="cookieconsent__actions">
    <button class="button button--small button--cookieconsent button--decline" type="button" data-consent="false">Decline tracking</button>
    <button class="button button--small button--cookieconsent button--accept" type="button" data-consent="true">Accept tracking</button>
  </div>
</div>
</div>
<div class="mobile-nav" dir="ltr">
  <div class="mobile-nav__cover"></div>
  <a href="#navigation" class="mobile-nav__toggle" aria-haspopup="true" role="button">Menu</a>
  <div class="mobile-nav__sheet">
    <div class="mobile-nav__region">
    
    </div>
    <nav class="mobile-nav__main-menu">
    <h2 class="visually-hidden">Main menu</h2>
    <ul class="mobile-nav__navbar">
    <li><a href="/">Home</a></li>
    <li><a href="/post/" class="active" aria-current="page">Posts</a></li>
    </ul>
    </nav>
  </div>
</div>
</body>
</html>
